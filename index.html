<!DOCTYPE html>
<html>
<head>
	<title>
		Algoritma Pembangkit Bilangan Prima
	</title>
	<link rel="stylesheet" href="style.css">	
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
	<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
</head>

<body>
	<div class="container">
		<div class="jumbotron">
			<h1>
				Algoritma Pembangkit Bilangan Prima
			</h1>
		</div>
	</div>
	<div class="container-fluid">
		<div class="row">
			<div class="col-sm-2">
				<ul class="nav nav-pills nav-stacked">
					<li class="active"><a data-toggle="pill" href="#intro">Pendahuluan</a></li>
					<li><a data-toggle="tab" href="#trialdivision">Trial Division</a></li>
					<li><a data-toggle="tab" href="#eratosthenes">Sieve of Eratosthenes</a></li>
					<li><a data-toggle="tab" href="#sundaram">Sieve of Sundaram</a></li>
					<li><a data-toggle="tab" href="#atkin">Sieve of Atkin</a></li>
				</ul>
			</div>
			<div class="col-sm-10">
				<div class="tab-content">
					<div id="intro" class="tab-pane fade in active">
						<h3>Pendahuluan</h3>
						<p>
							Dalam ilmu matematika, bilangan prima adalah bilangan yang hanya mempunyai 2 faktor positif yaitu 1 dan bilangan itu sendiri. Sepuluh bilangan prima yang pertama adalah 2,3,5,7,11,13,17,19,23,29. Sifat khusus dari bilangan prima ini diaplikasikan pada bidang komputasi antara lain pada public-key cryptography dan hash tables. Hal ini dikarenakan sulitnya memfaktorkan sebuah bilangan prima yang besar mengingat bilangan prima hanya mempunyai 2 buah faktor positif. Lalu bagaimana jika kita ingin membangkitkan sebuah bilangan prima acak terlebih lagi bilangan tersebut cukup  besar ?  Nah, pada artikel ini akan dibahas mengenai algoritma-algoritma yang umum digunakan untuk membangkitkan bilangan prima.
						</p>
						</br>
					</div>
					<div id="trialdivision" class="tab-pane fade">
						<h3>Trial Division</h3>
						<p>
							Algoritma ini sebenarnya lebih ditujukan untuk menguji apakah sebuah bilangan adalah prima. Pada trial division, sebuah bilangan n akan dibagi dengan bilangan bulat positif yang dimulai dari 2 dan tidak melebihi <img src=http://quicklatex.com/cache3/ql_316773a3603cb35a3e68b47537f479be_l3.png> . Jika ada minimal 1 bilangan yang dapat membagi n tanpa sisa, maka n bukanlah sebuah bilangan prima. Contoh, misalkan kita ingin menguji apakah 47 adalah bilangan prima. Maka kita akan membagi 47 dengan setiap bilangan mulai dari 2,3,4,5,6 . Karena tidak ada 1 bilangan pun yang habis membagi 47, maka 47 adalah bilangan prima. Dapat diamati bahwa banyaknya bilangan pembagi untuk menguji apakah  n adalah prima, bertambah banyak jika n bertambah besar. Hal ini bisa diatasi antara lain dengan membagi n juga dengan bilangan prima yang tidak melebihi <img src=http://quicklatex.com/cache3/ql_316773a3603cb35a3e68b47537f479be_l3.png> . Namun karena mencari daftar bilangan prima itu sendiri sulit, maka pada bagian selanjutnya akan dijelaskan metode sieving (penyaringan) yang lebih efisien dalam membangkitkan bilangan - bilangan prima.
						</p>
						</br>
					</div>
					<div id="eratosthenes" class="tab-pane fade">
						<h3>Sieve of Eratosthenes</h3>
						<p>
							Sieve of Eratosthenes atau Saringan Eratosthenes adalah algoritma sieving pertama yang digunakan untuk membangkitkan  semua bilangan prima yang lebih kecil atau sama dengan suatu bilangan n . Algoritma ini ditemukan oleh Eratosthenes sekitar tahun 300 SM, bekerja dengan cara menandai semua kelipatan dari bilangan prima yang lebih kecil dari n.
						</p>
						</br>
						<p>Algoritma :</p>
						<ol>
							<li>Diberikan list bilangan bulat positif 2, 3, 4, 5, ..., n dengan n adalah batas dari bilangan prima yang ingin dicari.</li>
							<li>Pertama, misalkan p = 2 sebagai bilangan prima yang pertama.</li>
							<li>Tandai bilangan dari list yang nilainya sama dengan kelipatan dari p, yaitu 2p, 3p, 4p, 5p, ... ( Contoh : jika p=2, maka bilangan 4, 6, 8, 10, 12, ... akan ditandai ).</li>
							<li>Jika p adalah bilangan terakhir di dalam list yang belum ditandai, lanjutkan ke langkah 5. Jika tidak, substitusi p dengan bilangan terkecil yang lebih besar dari p, yang belum ditandai. Lalu ulangi langkah 3.</li> 
							<li>Sekarang bilangan yang belum ditandai adalah bilangan prima yang dicari.</li>
						</ol>
						<p>
							Ide dasar dari algoritma ini adalah bahwa untuk setiap nilai p dapat dipastikan bahwa p adalah prima karena kita sudah menandai semua bilangan yang merupakan kelipatan dari bilangan yang lain yang lebih kecil dari p. Dari algoritma di atas juga dapat dilihat bahwa perbedaan yang paling  mendasar dari sieving dibandingkan  metode  trial division adalah bahwa pada metode sieving, pengujian hanya dilakukan sekali terhadap suatu bilangan prima beserta kelipatannya, sedangkan pada trial division, pengujian tetap dilakukan dengan kelipatan bilangannya. Hal ini sekaligus menyimpulkan bahwa untuk membangkitkan bilangan – bilangan prima yang relatif kecil kita dapat menggunakan metode Sieve of Eratosthenes. 
						</p>	
						<p>
							Perbaikan terhadap efisiensi algoritma ini dapat dilakukan antara lain dengan membuat daftar bilangan yang berisi bilangan ganjil saja, lalu penghapusan bilangan dari list dilakukan terhadap bilangan – bilangan yang merupakan kelipatan ganjil dari p yaitu 3p, 5p, 7p, 9p, dan seterusnya.
						</p>	
						<p>	
							Pada Euler’s Sieve yang juga menggunakan metode Sieve of Eratosthenes, bilangan yang merupakan kelipatan akan dihapus dari list, sehingga bilangan komposit hanya akan diperiksa 1 kali, berbeda dengan metode Sieve of Eratosthenes yang dijelaskan sebelumnya, di mana dimungkinkan penandaan bilangan komposit dilakukan lebih dari 1 kali, misal bilangan 15 akan ditandai ketika p =3 dan p = 5 karena 15 adalah kelipatan dari keduanya.
						</p>
						</br>
					</div>
					<div id="sundaram" class="tab-pane fade">
						<h3>Sieve of Sundaram</h3>
						<p>
							Algoritma ini ditemukan oleh seorang matematikawan India bernama S.P.Sundaram pada tahun 1934. Serupa dengan algoritma Eratosthenes, Sieve of Sundaram juga mengeliminasi bilangan komposit yang berada dalam bentuk i + j + 2ij dengan syarat:
						</p>
						<p>
							i , j adalah elemen bilangan bulat dan 1<= i <=j
							i + j + 2ij <= n
						</p>
						<p>Algoritma :</p>
						<ol>
							<li>Diberikan list bilangan bulat positif dari 1 sampai n.</li>
							<li>Eliminasi semua bilangan pada list yang memenuhi bentuk i + j + 2ij dengan syarat:</li>
								<ul style="list-style-type:none">
									<li>a.	i , j adalah elemen bilangan bulat dan 1<=i <=j</li>
									<li>b.	i + j + 2ij <= n</li>
								</ul>
							<li>Sekarang semua bilangan dalam bentuk  2k + 1 adalah bilangan prima, dengan k adalah semua bilangan yang belum tereliminasi pada list.</li> 
						</ol>
						<p>Pembuktian:</p>
						<p>
							Semua  bilangan 2k+1 yang telah kita hitung pada langkah 3 adalah bilangan ganjil.  Dapat kita amati juga bahwa ada bilangan ganjil yang lebih kecil dari 2k+2 tapi tidak terdapat pada list bilangan prima yang dihasilkan pada langkah 3. Misalkan bilangan-bilangan yang tidak terdapat pada list bilangan prima adalah q=2k + 1. Jika q bukan bilangan prima, maka kita dapat tulis ulang q sebagai :
						</p>
						<p>q = 2(i + j + 2ij) + 1</p>
						<p>q= 2i + 2j + 4ij + 1</p>
						<p>q= (2i + 1)(2j + 1)</p>
						<p>
							sehingga q adalah bilangan ganjil komposit.
						</p>
						<p>
							Jadi, dapat disimpulkan bahwa dengan mengeliminasi bilangan-bilangan yang berada dalam bentuk i+j+2ij berarti mengeliminasi semua bilangan ganjil yang dapat difaktorkan menjadi 2 buah bilangan ganjil yang lain. Dengan demikian list bilangan yang didapatkan pada langkah ke-3 berisi bilangan prima.
						</p>
						</br>
					</div>
					<div id="atkin" class="tab-pane fade">
						<h3>Sieve of Atkin</h3>
						<p>
							Algoritma ini ditemukan oleh A. O. L. Atkin and Daniel J. Bernstein pada tahun 2003. Sieve of Atkin adalah algoritma yang menggunakan binary quadratic forms dalam mengeliminasi bilangan komposit. Berbeda dengan dua algoritma sieving yang dijelaskan sebelumnya, algoritma Atkin agak lebih sulit dipahami namun memiliki performa yang lebih baik. Jadi ada beberapa istilah yang perlu dimengerti terlebih dahulu, antara lain :
						</p>
						<ol>
							<li>Binary quadratic forms : sebuah bilangan dapat direpresntasikan sebagai binary quadratic forms jika dapat ditulis ulang sebagai ax^2 + bxy +cy^2. Contoh : 67 = 2^2 + 7 x 3^2</li>
							<li>Squarefree number : bilangan yang tidak habis dibagi oleh semua bilangan kuadrat sempurna kecuali 1. Contoh : 1,2,3,5,6,7,10,11,13,14,15, ...</li>
						</ol>
						<p>Algoritma</p>
						<ol>
							<li>Bilangan 2, 3, 5 dianggap sebagai 3 bilangan prima pertama yang sudah diketahui.</li>
							<li>Buat list bilangan bulat dari 5 sampai n dengan n sebagai batas dari bilangan prima yang dicari. Beri status setiap bilangan sebagai bilangan komposit</li>
							<li>Untuk setiap bilangan k pada list, uji k dengan melakukan modulo 60, hasilnya ada beberapa kemungkinan:</li>
								<ul style="list-style-type:none">
									<li>- Jika hasil modulo 60 nya 1, 13, 17, 29, 37, 41, 49, 53 ( juga memiliki hasil 1 jika dilakukan modulo 4). Beri status k sebagai bilangan prima jika dan hanya jika banyaknya solusi terhadap binary quadratic forms 4x^2 +y^2 =k adalah ganjil dan k adalah squarefree number.</li>
									<li>- Jika hasil modulo 60 nya 7, 19, 31, 43 (juga memiliki hasil 1 jika dilakukan modulo 6). Beri status k sebagai bilangan prima jika dan hanya jika banyaknya solusi terhadap binary quadratic forms 3x^2 +y^2 =k adalah ganjil dan k adalah squarefree number.</li>
									<li>- Jika hasil modulo 60 nya 11, 23, 47, 59 (juga memiliki hasil 11 jika dilakukan modulo 12). Beri status k sebagai bilangan prima jika dan hanya jika banyaknya solusi terhadap binary quadratic forms 3x^2 -y^2 =k adalah ganjil dan k adalah squarefree number.</li>
									<li>- Selain 3 kondisi di atas tidak perlu mengganti status bilangan.</li>
								</ul>
							<li>Lakukan traversal dari bilangan pertama pada list.</li>
							<li>Ambil bilangan pertama pada list yang memiliki status bilangan prima, masukkan ke list bilangan prima P.</li>
							<li>Beri status sebagai bilangan komposit untuk setiap kelipatan dari kuadrat bilangan tersebut.</li>
							<li>Ulangi langkah 4 – 6, sampai tidak ada lagi bilangan prima di list awal.</li>
							<li>Sekarang, list P berisi bilangan prima yang lebih kecil sama dengan n.</li>
						</ol>
						</br>
					</div>
				</div>
			</div>
		</div>
	</div>
</body>

</html>